---
alwaysApply: true
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## TypeScript

- **Strict mode**: No implicit any, check nulls/undefined, handle array access, return from all paths
- **Path aliases**: Always use `@/*` imports
- **Branded types** (`@/types/branded.ts`): Prevent ID type mixing with `toProjectId()`, `toClientId()`, etc.

### Branded Types (REQUIRED)

Use branded types for all entity IDs throughout the codebase.

```typescript
// Import and convert
import { toProjectId, ProjectId } from '@/types/branded';
const { id } = await context.params;
const projectId = toProjectId(id);

// Service layer
async function getProject(id: ProjectId): Promise<Project> {
  return prisma.project.findUnique({ where: { id } });
}
```

**Requirements:**
- All ID parameters use branded types
- Route params converted using `toXxxId()` converters
- Service functions accept branded types, not raw numbers

### Type Organization

**Single Source of Truth:**
- **Prisma Schema**: Database models
- **types/index.ts**: Main entity types (from Prisma, extended as needed)
- **types/dto.ts**: Data transfer objects (derive using Partial/Pick/Omit)
- **types/branded.ts**: Branded ID types only
- **types/api.ts**: API-specific types

**Rules:**
- NO duplicate type definitions
- NO deprecated types - remove immediately
- NO string unions for enums - use strict enums
- Define enums ONCE in types/index.ts, import everywhere

**Null/Undefined:**
- Use `undefined` for optional/missing values (`?:`)
- Use `null` for intentional absence or database nulls (Prisma returns null)
- Check with optional chaining (`?.`) and nullish coalescing (`??`)

## Validation

All input validated with Zod schemas in `/src/lib/validation/schemas.ts`

## API Routes

### Standard Pattern (REQUIRED)

All API routes follow this 6-step pattern:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getCurrentUser } from '@/lib/services/auth/auth';
import { checkUserPermission } from '@/lib/services/permissions/permissionService';
import { getUserServiceLines } from '@/lib/services/service-lines/serviceLineService';
import { successResponse } from '@/lib/utils/apiUtils';
import { handleApiError } from '@/lib/utils/errorHandler';
import { sanitizeObject } from '@/lib/utils/sanitization';
import { toProjectId } from '@/types/branded';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    // 1. Authenticate (REQUIRED)
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    // 2. Parse and validate IDs using branded types
    const { id } = await context.params;
    const projectId = toProjectId(id);

    // 3. Check permission (REQUIRED)
    const hasPermission = await checkUserPermission(user.id, 'projects', 'READ');
    if (!hasPermission) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // 4. Filter by service line access (for list endpoints)
    const userServiceLines = await getUserServiceLines(user.id);
    const accessibleServiceLines = userServiceLines.map(sl => sl.serviceLine);

    // 5. Execute business logic
    const data = await prisma.resource.findMany({
      where: { serviceLine: { in: accessibleServiceLines } },
      select: { /* explicit fields only */ },
    });

    // 6. Return success response
    return NextResponse.json(successResponse(data));
  } catch (error) {
    return handleApiError(error, 'GET /api/resource');
  }
}
```

**For POST/PUT/PATCH, add between steps 2-3:**
```typescript
// Parse and sanitize input
const body = await request.json();
const sanitizedBody = sanitizeObject(body, { maxLength: 1000 });

// Validate with Zod
const validatedData = ResourceSchema.parse(sanitizedBody);
```

### API Route Checklist

- [ ] `getCurrentUser()` at start
- [ ] `checkUserPermission()` before business logic
- [ ] Branded types for all IDs
- [ ] `sanitizeObject()` + Zod validation on POST/PUT/PATCH
- [ ] Explicit field selection (`select:`)
- [ ] Service line filtering for list endpoints
- [ ] `successResponse()` / `handleApiError()` wrappers
- [ ] Proper HTTP status codes (200/201/400/401/403/404/500)
- [ ] Always await `context.params` in dynamic routes

### Key Patterns

- **Authentication**: `getCurrentUser()` at start of every protected route
- **Response Format**: Success `{ success: true, data: {...} }`, Error `{ success: false, error: "Message", code: "CODE" }`
- **Status Codes**: 200 (GET/PUT/DELETE), 201 (POST), 400 (validation), 401 (unauthorized), 403 (forbidden), 404 (not found), 500 (server error)

## Database (Prisma)

```typescript
import { prisma } from '@/lib/db/prisma';

// Always select only needed fields
const items = await prisma.resource.findMany({
  where: { userId },
  select: { id: true, name: true },
});

// Transactions for multi-step operations
await prisma.$transaction(async (tx) => {
  await tx.resource.update({...});
  await tx.auditLog.create({...});
});
```

### Performance Requirements

**Database:**
- ALWAYS use explicit field selection (`select:`)
- NEVER use `include` without necessity
- Batch related queries with `Promise.all()`
- Use transactions for multi-step operations
- Add indexes for frequently filtered fields
- Prevent N+1 queries (use includes or batch)

**Caching:**
- User permissions: cache 5 min (300s)
- Service line access: cache 10 min (600s)
- User data: cache 10 min (600s)
- Static/reference data: cache 30 min (1800s)

**Imports:**
- Static imports at top (no dynamic imports for core dependencies)
- Tree-shakeable exports
- Lazy load heavy dependencies only when needed

## Redis (Caching, Sessions, Queues)

### Caching

```typescript
import { cache, CACHE_PREFIXES } from '@/lib/services/cache/CacheService';

// Get/Set with TTL
const data = await cache.get<UserData>(`${CACHE_PREFIXES.USER}${userId}:profile`);
await cache.set(`${CACHE_PREFIXES.USER}${userId}:profile`, userData, 300);

// Invalidate by pattern
await cache.invalidate(`${CACHE_PREFIXES.USER}${userId}:`);
```

**Cache Prefixes (REQUIRED):**
- `SESSION` - Session data (3600s)
- `PERMISSION` - User permissions (300s)
- `RATE_LIMIT` - Rate limit counters
- `USER` - User data (600s)
- `PROJECT` - Project data (600s)
- `SERVICE_LINE` - Service line data (600s)
- `NOTIFICATION` - Notifications
- `ANALYTICS` - Analytics data (1800s)

### Sessions & Rate Limiting

**Session fingerprinting enabled by default** - prevents hijacking
**Rate limiting is async and Redis-backed** - works across all replicas

```typescript
import { checkRateLimit, RateLimitPresets } from '@/lib/utils/rateLimit';

const result = await checkRateLimit(request, RateLimitPresets.STANDARD);
if (!result.allowed) {
  return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
}
```

**Presets:** AI_ENDPOINTS (5/min), FILE_UPLOADS (10/min), STANDARD (30/min), READ_ONLY (100/min), AUTH_ENDPOINTS (10/min)

### Background Jobs

```typescript
import { queue } from '@/lib/queue/QueueService';

// Enqueue (persists across container restarts)
const jobId = await queue.enqueue('documents', 'extract', { documentId, filePath }, {
  priority: 1,
  maxAttempts: 3,
});
```

**Queue Types:** documents, emails, reports

**Never use fire-and-forget** - always use queue for long-running tasks

### Error Handling

```typescript
import { AppError, ErrorCodes } from '@/lib/utils/errorHandler';

// Throw specific errors
throw new AppError(400, 'Invalid input', ErrorCodes.VALIDATION_ERROR, { field: 'name' });
throw new AppError(404, 'Project not found', ErrorCodes.NOT_FOUND, { projectId });
throw new AppError(403, 'Insufficient permissions', ErrorCodes.FORBIDDEN);

// In catch blocks
catch (error) {
  return handleApiError(error, 'Operation context');
}
```

## Security & Authorization

**CRITICAL**: Security checks are NOT optional.

### Three-Tier Security Model

1. **System Level** - User.role: `SYSTEM_ADMIN` (full access), `USER` (requires service line + permissions)
2. **Service Line Level** - ServiceLineUser.role: `ADMINISTRATOR/PARTNER` > `MANAGER` > `SUPERVISOR` > `USER` > `VIEWER`
3. **Project Level** - ProjectUser.role: `ADMIN` > `REVIEWER` > `EDITOR` > `VIEWER`

Plus **granular permission system**: `PAGE` (dashboard, clients, projects, admin) and `FEATURE` (clients.create, projects.edit, etc.)

### Backend Security Pattern

```typescript
export async function GET(request: NextRequest) {
  try {
    // 1. Authenticate
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    // 2. Check permission
    const hasPermission = await checkUserPermission(user.id, 'resource-key', 'READ');
    if (!hasPermission) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });

    // 3. Filter by service line access
    const userServiceLines = await getUserServiceLines(user.id);
    const accessibleServiceLines = userServiceLines.map(sl => sl.serviceLine);
    
    const data = await prisma.resource.findMany({
      where: { serviceLine: { in: accessibleServiceLines } },
    });

    return NextResponse.json(successResponse(data));
  } catch (error) {
    return handleApiError(error, 'GET /api/resource');
  }
}
```

### Frontend Security

```typescript
// Component protection
import { PermissionGate } from '@/components/shared/PermissionGate';
<PermissionGate resource="clients.create" action="CREATE">
  <button onClick={handleCreate}>Create Client</button>
</PermissionGate>

// Hook-based checks
import { usePermission } from '@/hooks/permissions/usePermission';
const { hasPermission, isLoading } = usePermission('clients.edit', 'UPDATE');
if (isLoading) return <LoadingSpinner />;
return hasPermission ? <EditButton /> : null;
```

### Security Checklist

**Backend:**
- [ ] `getCurrentUser()` at start
- [ ] `checkUserPermission()` before business logic
- [ ] Filter by service line access (`getUserServiceLines()`)
- [ ] For projects: `checkProjectAccess()`
- [ ] For approvals: `canApproveAcceptance()` or `canApproveEngagementLetter()`
- [ ] Return 401/403/404 appropriately
- [ ] Use `handleApiError()` in catch blocks

**Frontend:**
- [ ] Wrap sensitive UI with `<PermissionGate>`
- [ ] Use `usePermission()` for conditional rendering
- [ ] Protect pages with permission checks + redirect
- [ ] Show loading states

**Database:**
- [ ] Filter by accessible service lines
- [ ] Verify project membership
- [ ] Select only needed fields
- [ ] Use transactions for multi-step operations

### Common Permission Resources

**Pages**: `dashboard`, `clients`, `projects`, `analytics`, `bd`, `admin`, `admin.users`, `admin.templates`, `admin.service-lines`, `admin.permissions`

**Features**: `clients.create/edit/delete/view`, `projects.create/edit/delete/archive/assign-users`, `documents.upload/download/delete`, `acceptance.create/approve/view`, `mapping.create/edit/delete`, `adjustments.create/approve/delete`, `opinions.create/edit/generate/publish`, `reports.generate/export`, `bd.opportunities.create/edit/delete`

### Authorization Utilities

| Utility | Purpose |
|---------|---------|
| `getCurrentUser()` | Get current session user |
| `checkProjectAccess(userId, projectId, role?)` | Check project access |
| `checkUserPermission(userId, resource, action)` | Check granular permission |
| `getUserServiceLines(userId)` | Get accessible service lines |
| `canApproveAcceptance(userId, projectId)` | Check approval permission |
| `isSystemAdmin(userId)` | Check if SYSTEM_ADMIN |

**From `@/lib/services/auth/authorization`**: `isSystemAdmin()`, `getUserSystemRole()`, `getServiceLineRole()`, `isPartner()`, `isManager()`, `hasServiceLineAccess()`, `canApproveEngagementLetter()`, `checkFeaturePermission()`

**From `@/lib/services/permissions/permissionService`**: `getUserPermissions()`, `getRolePermissions()`, `getPermissionMatrix()`, `checkUserPermissions()`, `checkUserHasAnyPermission()`

### Security Best Practices

1. **Defense in Depth**: Check permissions at multiple levels (system, service line, project)
2. **Fail Secure**: Default to deny access
3. **Explicit Checks**: Never assume permission
4. **Granular Permissions**: Use specific resource keys (e.g., `clients.edit` not `clients`)
5. **Service Line Isolation**: Users only see data from their service lines (unless SYSTEM_ADMIN)
6. **Project Membership**: Users must be assigned to projects (unless Partner/Admin)
7. **Input Validation**: Always validate/sanitize with Zod schemas
8. **Error Messages**: Don't leak information (generic "Forbidden")

## Best Practices

**API Routes**: 
- Always authenticate with `getCurrentUser()` at start
- Validate input with Zod schemas
- Use `successResponse`/`handleApiError` wrappers
- Use branded types for all IDs
- Select only needed DB fields with explicit `select:`
- Use transactions for multi-step operations
- Sanitize input before validation on POST/PUT/PATCH
- Filter by service line access for list endpoints
- Await rate limiting checks (`await checkRateLimit()`)
- Use background jobs for long-running tasks (`queue.enqueue()`)

**Components**: 
- Use `@/` imports (path aliases)
- Use named exports (avoid default exports)
- Server Components by default, add `'use client'` only when needed
- Wrap sensitive UI with `<PermissionGate>`
- Use `usePermission()` for conditional rendering
- Use custom modals for confirmations, never browser popups (`window.confirm/alert/prompt`)
- Component organization: `ui/` (base), `layout/` (nav/headers), `shared/` (reusable), `features/<domain>/` (feature-specific)

**TypeScript**: 
- Strict mode enabled
- Use branded types for all entity IDs
- Type all parameters and returns explicitly
- Check undefined/null before access (optional chaining, nullish coalescing)
- Define types once, import everywhere
- Derive DTOs from base types using Partial/Pick/Omit
- Always verify build passes before committing

**Security**: 
- Validate all input at API boundaries (Zod schemas + sanitization)
- Check authentication in every protected route
- Verify authorization before data access
- Never expose secrets in client code
- Use Prisma (parameterized queries)
- Filter by service line access
- Verify project membership
- Use granular permission checks
- Don't leak implementation details in error messages
- Session fingerprinting prevents hijacking
- Rate limiting enforced across all instances (Redis-backed)
- Cache keys automatically sanitized

**Performance**: 
- React Query for server state caching (client-side)
- Redis for server-side caching (sessions, permissions, service lines)
- Cache with appropriate TTLs (sessions: 1h, permissions: 5min, user data: 10min)
- Use namespace prefixes for all cache keys (`CACHE_PREFIXES.*`)
- Select specific DB fields (avoid `SELECT *`)
- Use DB indexes for frequently filtered fields
- Implement pagination for large datasets
- Prevent N+1 queries with includes or batch queries
- Server Components by default (less JavaScript)
- Static imports for core dependencies
- Background jobs for long tasks (documents, emails, reports)

**Code Quality**:
- Extract utilities for code used in 3+ places
- Keep files under 500 lines
- Delete backup files (.bak, .old) immediately
- Use camelCase for file names
- No duplicate type definitions
- Remove deprecated code immediately
- Use structured logging with context
- Business logic in `/src/lib/services/<domain>/`
- Use React Query for server state, useState for UI state

**Core Principle**: All code must follow these standards. Security checks are NOT optional. Performance patterns are REQUIRED. Type safety is MANDATORY.
