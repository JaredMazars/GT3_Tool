---
alwaysApply: true
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## TypeScript

- **Strict mode**: No implicit any, check nulls/undefined, handle array access, return from all paths
- **Path aliases**: Always use `@/*` imports
- **Branded types** (`@/types/branded.ts`): Prevent ID type mixing with `toProjectId()`, `toClientId()`, etc.

## Validation

All input validated with Zod schemas in `/src/lib/validation/schemas.ts`

## API Routes

### Standard Pattern

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getCurrentUser } from '@/lib/services/auth/auth';
import { checkUserPermission } from '@/lib/services/permissions/permissionService';
import { getUserServiceLines } from '@/lib/services/service-lines/serviceLineService';
import { successResponse } from '@/lib/utils/apiUtils';
import { handleApiError } from '@/lib/utils/errorHandler';

export async function GET(request: NextRequest) {
  try {
    // 1. Authenticate
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    // 2. Check permission
    const hasPermission = await checkUserPermission(user.id, 'resource-key', 'READ');
    if (!hasPermission) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });

    // 3. Filter by service line access (for list endpoints)
    const userServiceLines = await getUserServiceLines(user.id);
    const accessibleServiceLines = userServiceLines.map(sl => sl.serviceLine);
    
    const data = await prisma.resource.findMany({
      where: { serviceLine: { in: accessibleServiceLines } },
    });

    return NextResponse.json(successResponse(data));
  } catch (error) {
    return handleApiError(error, 'GET /api/resource');
  }
}
```

### Dynamic Routes

```typescript
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  const user = await getCurrentUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  
  const { id } = await context.params; // Always await params
  const hasAccess = await checkProjectAccess(user.id, parseInt(id));
  if (!hasAccess) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  
  // ... fetch and return data
}
```

### Key Patterns

- **Authentication**: `getCurrentUser()` at start of every protected route
- **Request/Response**: Success `{ success: true, data: {...} }`, Error `{ success: false, error: "Message", code: "CODE" }`
- **Status Codes**: 200 (GET/PUT/DELETE), 201 (POST), 400 (validation), 401 (unauthorized), 403 (forbidden), 404 (not found), 500 (server error)

## Database (Prisma)

```typescript
import { prisma } from '@/lib/db/prisma'; // Singleton

// Query - select only needed fields
const items = await prisma.resource.findMany({
  where: { userId },
  select: { id: true, name: true },
});

// Transactions for multi-step operations
await prisma.$transaction(async (tx) => {
  await tx.resource.update({...});
  await tx.auditLog.create({...});
});
```

## Error Handling

```typescript
import { AppError, ErrorCodes } from '@/lib/utils/errorHandler';

// Throw structured error
throw new AppError(404, 'Not found', ErrorCodes.NOT_FOUND, { id });

// API routes - always use handleApiError in catch
catch (error) {
  return handleApiError(error, 'GET /api/resource');
}
```

## Services

Business logic in `/src/lib/services/<domain>/`. Pure functions or classes, no request/response handling.

## Components

### Organization
- `components/ui/` - Base components (shadcn/ui)
- `components/layout/` - Nav, headers, sidebars
- `components/shared/` - Reusable across features
- `components/features/<domain>/` - Feature-specific

### Patterns
- Use named exports (avoid default)
- Default: Server Components. Add `'use client'` when using hooks/events/React Query

## State Management

- **React Query** for server state (caching, mutations, invalidation)
- **useState** for form state, UI state (modals, toggles), component-specific state

## Logging

```typescript
import { logger } from '@/lib/utils/logger';
logger.info('Event', { context });
logger.error('Error', { error: error.message });
```

Don't log secrets/PII. Use structured objects.

## Best Practices

**API Routes**: Always authenticate, validate input with Zod, use `successResponse`/`handleApiError`, await `context.params`, use branded types, select only needed DB fields, use transactions for multi-step operations

**Components**: Use `@/` imports, named exports, Server Components by default, co-locate hooks, extract to `shared/` when used by 2+ features

**TypeScript**: Strict mode, check undefined/null before access, use branded types for IDs, type all parameters/returns, always verify build passes

**Security**: Validate all input, check authentication in every protected route, verify authorization, never expose secrets in client code, use Prisma (parameterized queries)

**Performance**: React Query for caching, select specific DB fields, use DB indexes, implement pagination, Server Components by default, optimize loading/reloading

## Security & Authorization

**CRITICAL**: All new code MUST follow these security patterns. Security checks are NOT optional.

### Three-Tier Security Model

1. **System Level** - Global roles (User.role): `SYSTEM_ADMIN` (full access), `USER` (requires service line + permissions)
2. **Service Line Level** - Department roles (ServiceLineUser.role): `ADMINISTRATOR/PARTNER` > `MANAGER` > `SUPERVISOR` > `USER` > `VIEWER`
3. **Project Level** - Project roles (ProjectUser.role): `ADMIN` > `REVIEWER` > `EDITOR` > `VIEWER`

Plus **granular permission system**: `PAGE` (dashboard, clients, projects, admin, etc.) and `FEATURE` (clients.create, projects.edit, etc.)

### Backend Security Pattern

```typescript
export async function GET(request: NextRequest) {
  try {
    // 1. Authenticate
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    // 2. Check permission
    const hasPermission = await checkUserPermission(user.id, 'resource-key', 'READ');
    if (!hasPermission) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });

    // 3. Filter by service line access (list endpoints)
    const userServiceLines = await getUserServiceLines(user.id);
    const accessibleServiceLines = userServiceLines.map(sl => sl.serviceLine);
    
    const data = await prisma.resource.findMany({
      where: { serviceLine: { in: accessibleServiceLines } },
    });

    return NextResponse.json(successResponse(data));
  } catch (error) {
    return handleApiError(error, 'GET /api/resource');
  }
}
```

### Frontend Security Patterns

```typescript
// Component-Level Protection
import { PermissionGate } from '@/components/shared/PermissionGate';

<PermissionGate resource="clients.create" action="CREATE">
  <button onClick={handleCreate}>Create Client</button>
</PermissionGate>

// Hook-Based Checks
import { usePermission } from '@/hooks/permissions/usePermission';

function MyComponent() {
  const { hasPermission, isLoading } = usePermission('clients.edit', 'UPDATE');
  if (isLoading) return <LoadingSpinner />;
  return hasPermission ? <EditButton /> : null;
}

// Page-Level Protection
export default function AdminPage() {
  const router = useRouter();
  const { hasPermission, isLoading } = usePermission('admin.users', 'READ');

  useEffect(() => {
    if (!isLoading && !hasPermission) router.push('/dashboard');
  }, [hasPermission, isLoading, router]);

  if (isLoading) return <LoadingSpinner />;
  if (!hasPermission) return null;
  return <AdminContent />;
}
```

### Security Checklist

**Backend (API Routes)**
- [ ] Authenticate with `getCurrentUser()` at start
- [ ] Check permission with `checkUserPermission()`
- [ ] Filter data by service line access (`getUserServiceLines()`)
- [ ] For project routes, verify `checkProjectAccess()`
- [ ] For approvals, use `canApproveAcceptance()` or `canApproveEngagementLetter()`
- [ ] Return 401/403/404 appropriately
- [ ] Use `handleApiError()` in catch blocks

**Frontend (Components & Pages)**
- [ ] Wrap sensitive UI with `<PermissionGate>`
- [ ] Use `usePermission()` for conditional rendering
- [ ] Protect pages with permission checks + redirect
- [ ] Show loading states, provide clear fallback messages

**Database Queries**
- [ ] Filter by accessible service lines for list queries
- [ ] Verify project membership before accessing project data
- [ ] Select only needed fields
- [ ] Use transactions for multi-step operations

### Common Permission Resources

**Pages**: `dashboard`, `clients`, `projects`, `analytics`, `bd`, `admin`, `admin.users`, `admin.templates`, `admin.service-lines`, `admin.permissions`

**Features**: `clients.create/edit/delete/view`, `projects.create/edit/delete/archive/assign-users`, `documents.upload/download/delete`, `acceptance.create/approve/view`, `mapping.create/edit/delete`, `adjustments.create/approve/delete`, `opinions.create/edit/generate/publish`, `reports.generate/export`, `bd.opportunities.create/edit/delete`

### Authorization Utilities

| Utility | Purpose |
|---------|---------|
| `getCurrentUser()` | Get current session user |
| `checkProjectAccess(userId, projectId, role?)` | Check project access |
| `checkUserPermission(userId, resource, action)` | Check granular permission |
| `getUserServiceLines(userId)` | Get accessible service lines with stats |
| `canApproveAcceptance(userId, projectId)` | Check approval permission |
| `isSystemAdmin(userId)` | Check if SYSTEM_ADMIN or legacy ADMIN |

**From `@/lib/services/auth/authorization`**: `isSystemAdmin()`, `getUserSystemRole()`, `getServiceLineRole()`, `isPartner()`, `isManager()`, `hasServiceLineAccess()`, `canApproveEngagementLetter()`, `checkFeaturePermission()`

**From `@/lib/services/permissions/permissionService`**: `getUserPermissions()`, `getRolePermissions()`, `getPermissionMatrix()`, `checkUserPermissions()`, `checkUserHasAnyPermission()`

### Security Best Practices

1. **Defense in Depth**: Check permissions at multiple levels (system, service line, project)
2. **Fail Secure**: Default to deny access if checks fail
3. **Explicit Checks**: Never assume permission
4. **Granular Permissions**: Use specific resource keys (e.g., `clients.edit` not `clients`)
5. **Service Line Isolation**: Users only see data from their service lines (unless SYSTEM_ADMIN)
6. **Project Membership**: Users must be assigned to projects (unless Partner/Admin in service line)
7. **Audit Trail**: Track actions (createdBy, updatedBy fields)
8. **Input Validation**: Always validate/sanitize (use Zod schemas)
9. **Error Messages**: Don't leak information (generic "Forbidden")
10. **Loading States**: Handle permission loading gracefully in UI
