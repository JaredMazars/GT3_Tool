---
description: Tool System Architecture & Patterns - Comprehensive guide for implementing and maintaining the modular tool system
alwaysApply: false
---

# Tool System Architecture & Patterns

## Core Principles

1. **Consistent Naming**: All Prisma relations use PascalCase matching model names
2. **Junction Tables**: Named as `[Entity1][Entity2]` (e.g., `TaskTool`, `ServiceLineTool`)
3. **User Relations**: Always use full descriptive relation names with format `User_[Model]_[field]ToUser`
4. **Foreign Keys**: All user ID references MUST have proper User relations, never plain strings if querying user data

## Prisma Schema Patterns

### Tool Entity Structure

**Main Entity**: `Tool`
- Fields: `id`, `name`, `code`, `description`, `icon`, `componentPath`, `active`, `sortOrder`
- Relations: `ServiceLineTool[]`, `TaskTool[]`, `ToolSubTab[]`

**Child Entity**: `ToolSubTab`
- Belongs to one Tool
- Has own: `id`, `name`, `code`, `icon`, `componentPath`, `active`, `sortOrder`

**Junction Tables**: `TaskTool`, `ServiceLineTool`
- Connect tools to tasks and service lines respectively

### Relation Naming Convention

**Format**: PascalCase matching the model name exactly

```prisma
model Tool {
  ServiceLineTool ServiceLineTool[]  // PascalCase, plural
  TaskTool        TaskTool[]         // PascalCase, plural
  ToolSubTab      ToolSubTab[]       // PascalCase, plural
}

model ToolSubTab {
  Tool Tool @relation(...)           // PascalCase, singular
}

model TaskTool {
  Tool Tool @relation(...)           // PascalCase, singular
  Task Task @relation(...)           // PascalCase, singular
  User User @relation(...)           // PascalCase, singular
}
```

### Junction Table Pattern

All junction tables MUST follow this structure:

```prisma
model TaskTool {
  id        Int      @id @default(autoincrement())
  taskId    Int      // Foreign key to Task
  toolId    Int      // Foreign key to Tool
  addedBy   String   // Foreign key to User
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations - all PascalCase
  User User @relation(fields: [addedBy], references: [id], onUpdate: NoAction)
  Task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  Tool Tool @relation(fields: [toolId], references: [id], onDelete: Cascade)
  
  // Constraints
  @@unique([taskId, toolId])
  @@index([taskId])
  @@index([toolId])
  @@index([addedBy])
  @@index([taskId, sortOrder])
}
```

**Key Requirements:**
- Auto-increment `id` primary key
- Foreign keys for both entities being joined
- `createdAt` and `updatedAt` timestamps
- Unique constraint on logical pair (prevents duplicates)
- Indexes on foreign keys and common query patterns
- `sortOrder` for ordered collections

### User Relation Pattern

**For multiple relations to same User entity, use descriptive relation names:**

```prisma
model ReviewNote {
  // Foreign key fields
  raisedBy         String
  assignedTo       String?
  addressedBy      String?
  currentOwner     String?
  lastRespondedBy  String?
  
  // User relations - descriptive names prevent conflicts
  User_ReviewNote_raisedByToUser         User  @relation("ReviewNote_raisedByToUser", fields: [raisedBy], references: [id], onUpdate: NoAction)
  User_ReviewNote_assignedToToUser       User? @relation("ReviewNote_assignedToToUser", fields: [assignedTo], references: [id], onDelete: NoAction, onUpdate: NoAction)
  User_ReviewNote_addressedByToUser      User? @relation("ReviewNote_addressedByToUser", fields: [addressedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
  User_ReviewNote_currentOwnerToUser     User? @relation("ReviewNote_currentOwnerToUser", fields: [currentOwner], references: [id], onDelete: NoAction, onUpdate: NoAction)
  User_ReviewNote_lastRespondedByToUser  User? @relation("ReviewNote_lastRespondedByToUser", fields: [lastRespondedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  // Reverse relations in User model
  ReviewNote_ReviewNote_raisedByToUser         ReviewNote[] @relation("ReviewNote_raisedByToUser")
  ReviewNote_ReviewNote_assignedToToUser       ReviewNote[] @relation("ReviewNote_assignedToToUser")
  ReviewNote_ReviewNote_addressedByToUser      ReviewNote[] @relation("ReviewNote_addressedByToUser")
  ReviewNote_ReviewNote_currentOwnerToUser     ReviewNote[] @relation("ReviewNote_currentOwnerToUser")
  ReviewNote_ReviewNote_lastRespondedByToUser  ReviewNote[] @relation("ReviewNote_lastRespondedByToUser")
}
```

**CRITICAL**: NEVER leave user ID fields as plain strings without relations if you need to query or display user data (name, email, etc.).

**Relation Naming Format**:
- Forward: `User_[Model]_[fieldName]ToUser`
- Reverse: `[Model]_[Model]_[fieldName]ToUser` (duplicated model name for uniqueness)
- Relation string: `"[Model]_[fieldName]ToUser"`

## Tool Registration Process

### 1. Code Structure

```
src/components/tools/
  ├── ToolRegistry.ts              # Client-side registry (imports components)
  ├── ToolRegistry.server.ts       # Server-side registry (for API/server use)
  ├── types.ts                     # Shared TypeScript interfaces
  └── {ToolName}/
      ├── index.tsx                # Main component export + config
      ├── components/              # Sub-components
      │   ├── FeatureA.tsx
      │   └── FeatureB.tsx
      └── hooks/                   # Tool-specific hooks (optional)
```

### 2. Tool Component Interface

All tools MUST implement this interface:

```typescript
interface ToolComponentProps {
  taskId: string;              // Required: Task context
  toolId?: number;             // Optional: Specific tool instance ID
  subTabs?: Array<{            // Optional: Sub-tabs from DB
    id: number;
    name: string;
    code: string;
    icon?: string;
    sortOrder: number;
  }>;
  initialNoteId?: number;      // Optional: For deep linking (e.g., review notes)
}

export type ToolComponent = React.ComponentType<ToolComponentProps>;
```

### 3. Tool Config Structure

Each tool MUST export a config:

```typescript
interface ToolModuleConfig {
  code: string;              // MUST match DB tool.code exactly
  name: string;              // Display name
  description: string;       // Brief description
  version: string;           // Semantic version
  defaultSubTabs?: Array<{   // Optional: Default sub-tabs for registration
    id: string;              // Code/identifier
    label: string;           // Display name
    icon: string;            // Icon name (lucide-react)
  }>;
}
```

**Example Tool Export**:

```typescript
// src/components/tools/ReviewNotebookTool/index.tsx
export const ReviewNotebookTool: ToolComponent = ({ taskId, toolId, subTabs, initialNoteId }) => {
  // Tool implementation
};

export const reviewNotebookToolConfig: ToolModuleConfig = {
  code: 'review-notebook',
  name: 'Review Notebook',
  description: 'Manage review notes and action items',
  version: '1.0.0',
  defaultSubTabs: [
    { id: 'notes', label: 'Notes', icon: 'FileText' },
    { id: 'categories', label: 'Categories', icon: 'Folder' },
  ],
};
```

### 4. Registration Steps

**Step 1: Create Tool Component**
1. Create directory: `src/components/tools/{ToolName}/`
2. Implement component following `ToolComponentProps` interface
3. Export component and config from `index.tsx`

**Step 2: Register in Code**
1. Import in `src/components/tools/ToolRegistry.ts`
2. Add to `TOOL_MODULES` array:
```typescript
const TOOL_MODULES: ToolModule[] = [
  { component: YourTool, config: yourToolConfig },
];
```

**Step 3: Register in Database**
```bash
# Use API endpoint to register from code
POST /api/tools/register
Body: { "code": "your-tool-code" }
```

This creates:
- Tool record in DB
- ToolSubTab records (if defaultSubTabs defined)

**Step 4: Assign to Service Lines**
```bash
# Assign tool to service line groups
PUT /api/tools/[id]/assignments
Body: { "subServiceLineGroups": ["TAX-CORP", "TAX-INDIV"] }
```

**Step 5: Use on Tasks**
```bash
# Add tool to specific task
POST /api/tools/task/[taskId]
Body: { "toolId": 123, "sortOrder": 0 }
```

## API Patterns

### Tool Management Endpoints

**Tool CRUD**:
- `GET /api/tools` - List all tools (with optional `?active=true` filter)
- `POST /api/tools` - Create tool manually (for non-code tools)
- `POST /api/tools/register` - Register tool from code registry (preferred)
- `GET /api/tools/[id]` - Get tool details with counts
- `PUT /api/tools/[id]` - Update tool metadata
- `DELETE /api/tools/[id]` - Delete tool (fails if assigned to tasks)

**Service Line Assignments**:
- `GET /api/tools/[id]/assignments` - Get assigned service line groups
- `PUT /api/tools/[id]/assignments` - Update assignments (replaces all)

**Tool Discovery**:
- `GET /api/tools/available?subServiceLineGroup=TAX-CORP` - Get tools available for service line

### Task-Tool Relationship

- `GET /api/tools/task/[taskId]` - Get all tools assigned to task
- `POST /api/tools/task/[taskId]` - Add tool to task
- `DELETE /api/tools/task/[taskId]?toolId=X` - Remove tool from task

### API Response Patterns

All tool APIs return PascalCase relations matching Prisma:

```typescript
// GET /api/tools/[id]
{
  "data": {
    "id": 1,
    "name": "Review Notebook",
    "code": "review-notebook",
    "ToolSubTab": [              // PascalCase!
      { "id": 1, "name": "Notes", "code": "notes" }
    ],
    "ServiceLineTool": [         // PascalCase!
      { "subServiceLineGroup": "TAX-CORP" }
    ],
    "_count": {
      "TaskTool": 5,             // PascalCase!
      "ToolSubTab": 2,
      "ServiceLineTool": 3
    }
  }
}
```

## TypeScript Type Patterns

### Relation Names MUST Match Prisma Exactly

```typescript
// ❌ WRONG - assuming camelCase
interface TaskTool {
  tool: {
    subTabs: SubTab[];
  };
}

// ✅ CORRECT - PascalCase matching schema
interface TaskTool {
  id: number;
  taskId: number;
  toolId: number;
  Tool: {              // PascalCase
    id: number;
    name: string;
    code: string;
    ToolSubTab?: {     // PascalCase
      id: number;
      name: string;
      code: string;
    }[];
  };
}
```

### Frontend Component Pattern

```typescript
// ❌ DON'T: Assume camelCase
const toolName = taskTool.tool.name;
const subTabs = taskTool.tool.subTabs;

// ✅ DO: Use PascalCase matching schema
const toolName = taskTool.Tool.name;
const subTabs = taskTool.Tool.ToolSubTab;
```

### Type Definition Location

- **Prisma-generated types**: Use directly from `@prisma/client`
- **Extended types**: Define in `src/types/` with proper imports
- **Component props**: Define in component file or shared `types.ts`

## Integration with Approval System

### Alignment Requirements

Both Tool and Approval systems follow the same patterns:

1. **Relation Naming**: PascalCase with descriptive names for User relations
2. **Junction Tables**: Follow `[Entity1][Entity2]` naming pattern
3. **Foreign Keys**: Require proper relations, not plain strings
4. **Service Layer**: Use centralized service pattern (`toolService`, `approvalService`)
5. **Cache Invalidation**: Explicit cache invalidation after mutations

### Approval-Tool Integration Pattern

When tools generate items requiring approval:

```typescript
import { approvalService } from '@/lib/services/approvals/approvalService';

// Step 1: Create the tool-specific item
const reviewNote = await prisma.reviewNote.create({
  data: {
    taskId,
    title: 'Review note requiring approval',
    raisedBy: user.id,
    // ... other fields
  },
});

// Step 2: Create approval workflow
const approval = await approvalService.createApproval({
  workflowType: 'REVIEW_NOTE',
  workflowId: reviewNote.id,
  title: `Review note: ${reviewNote.title}`,
  requestedById: user.id,
  context: {
    taskId,
    categoryId: reviewNote.categoryId,
  },
});

// Step 3: Link approval back to tool item
await prisma.reviewNote.update({
  where: { id: reviewNote.id },
  data: { approvalId: approval.id },
});

// Step 4: Invalidate caches
await invalidateApprovalsCache();
```

### Approval System Relation Pattern

Approvals follow the same User relation pattern:

```prisma
model Approval {
  requestedById String
  completedById String?
  
  User_Approval_requestedByIdToUser User  @relation("Approval_requestedByIdToUser", ...)
  User_Approval_completedByIdToUser User? @relation("Approval_completedByIdToUser", ...)
}
```

## Validation Rules

### Schema Requirements Checklist

When creating/modifying tool-related schemas:

- [ ] All user ID fields have corresponding User relations
- [ ] All relation names use PascalCase matching model names
- [ ] Junction tables follow `[Entity1][Entity2]` naming convention
- [ ] All foreign keys have proper indexes
- [ ] Unique constraints on logical pairs (e.g., `[taskId, toolId]`)
- [ ] Timestamps (`createdAt`, `updatedAt`) on all tables
- [ ] Cascade deletes configured appropriately
- [ ] Optional fields use `?` in schema and TypeScript

### Code Requirements Checklist

When writing code that uses tools:

- [ ] TypeScript types match Prisma relation names exactly (PascalCase)
- [ ] Service layer uses explicit `select:` with PascalCase relations
- [ ] Frontend components access relations with PascalCase (e.g., `taskTool.Tool`)
- [ ] All mutations call appropriate cache invalidation
- [ ] Error handling uses `AppError` with proper `ErrorCodes`
- [ ] API routes use `secureRoute` wrapper with appropriate `feature`
- [ ] Input validation uses Zod schemas from `/src/lib/validation/schemas.ts`

### Tool-Specific Requirements

Before registering a new tool:

- [ ] Tool code is unique and matches registry export
- [ ] Component implements `ToolComponentProps` interface
- [ ] Component path in DB points to valid module
- [ ] All sub-tabs have valid component paths (or use parent's)
- [ ] Tool is registered in `ToolRegistry.ts` TOOL_MODULES
- [ ] Tool config exported alongside component
- [ ] Service line assignments created before task assignment

## Service Layer Pattern

### Restore Relations After Schema Update

After adding the missing ReviewNote relations, restore them in the service layer:

```typescript
// src/lib/services/review-notes/reviewNoteService.ts
const reviewNoteSelect = {
  // ... other fields ...
  User_ReviewNote_currentOwnerToUser: {
    select: {
      id: true,
      name: true,
      email: true,
    },
  },
  User_ReviewNote_lastRespondedByToUser: {
    select: {
      id: true,
      name: true,
      email: true,
    },
  },
  // ... other relations ...
};
```

### Service Method Pattern

```typescript
// Get tool with all relations
export async function getToolById(toolId: number) {
  return await prisma.tool.findUnique({
    where: { id: toolId },
    select: {
      id: true,
      name: true,
      code: true,
      description: true,
      ToolSubTab: {                    // PascalCase
        orderBy: { sortOrder: 'asc' },
        select: {
          id: true,
          name: true,
          code: true,
        },
      },
      ServiceLineTool: {               // PascalCase
        select: {
          subServiceLineGroup: true,
        },
      },
      _count: {
        select: {
          TaskTool: true,              // PascalCase
          ToolSubTab: true,
          ServiceLineTool: true,
        },
      },
    },
  });
}
```

## Migration Checklist

When updating existing patterns to match this standard:

1. ✅ Update Prisma schema with new relations
2. ✅ Run `prisma generate` to update Prisma Client
3. ✅ Update TypeScript type definitions to match
4. ✅ Update service layer queries with new relation names
5. ✅ Update API route handlers to use new relation names
6. ✅ Update frontend components to access PascalCase relations
7. ✅ Test all CRUD operations end-to-end
8. ✅ Verify cache invalidation works correctly
9. ✅ Run `bun run build` to catch any type errors
10. ✅ Deploy and monitor for errors

## Common Mistakes to Avoid

### ❌ DON'T: Mix camelCase and PascalCase

```typescript
// Wrong
const tool = await prisma.tool.findUnique({
  include: {
    subTabs: true,      // camelCase - doesn't exist!
    ServiceLineTool: true,  // PascalCase - correct
  },
});
```

### ❌ DON'T: Leave user fields without relations

```prisma
// Wrong - can't query user data
model ReviewNote {
  currentOwner String?
  // Missing: User relation!
}
```

### ❌ DON'T: Use non-unique relation names

```prisma
// Wrong - causes relation conflicts
model ReviewNote {
  raisedBy String
  assignedTo String
  
  RaisedBy User @relation(fields: [raisedBy], ...)  // Ambiguous!
  AssignedTo User @relation(fields: [assignedTo], ...)  // Ambiguous!
}
```

### ❌ DON'T: Forget cache invalidation

```typescript
// Wrong - stale cache
await prisma.taskTool.create({ data: { ... } });
// Missing: await invalidateOnTaskMutation(taskId);
```

### ✅ DO: Follow consistent patterns

```typescript
// Correct
const tool = await prisma.tool.findUnique({
  include: {
    ToolSubTab: true,        // PascalCase matching schema
    ServiceLineTool: true,   // PascalCase matching schema
  },
});

// Access relations correctly
tool.ToolSubTab.forEach(subTab => {
  console.log(subTab.name);
});
```

## Related Documentation

- **Approval System**: `.cursor/rules/approval-system-rules.mdc`
- **Blob Storage**: `.cursor/rules/blob-storage-rules.mdc`
- **Consolidated Rules**: `.cursor/rules/consolidated.mdc`
- **Design System**: `.cursor/rules/forvis-design-rules.mdc`

## Questions or Issues?

If you encounter patterns that don't match this guide:
1. Check if it's a legacy pattern that needs updating
2. Verify against the Prisma schema (`prisma/schema.prisma`)
3. Run `prisma generate` if schema was recently updated
4. Check TypeScript types match Prisma relations exactly
5. Ensure all User relations use descriptive naming convention
